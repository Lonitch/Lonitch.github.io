---
layout: page
title: Tags
permalink: /tags/
---

{% if site.posts.size == 0 %}
  <h2>No post found</h2>
{% endif %}

{%raw%}
<div id="graph-container" style="width:55%;height:600px">
  <!-- The graph will be rendered here -->
</div>
<script>
  // Define the container for the graph
const graphContainer = document.getElementById('graph-container');

// Define a function to fetch and parse .md files
// Define a function to fetch and parse .md files
async function fetchAndParseMarkdownFiles(fileNames) {
    // Parse each .md file and extract tags
    const tagRegExp = /\[([^\]]+)\]/g;
    const tagsByFile = {};


    for (const fileName of fileNames) {
        const response = await fetch(".."+fileName);
        const text = await response.text();
        // Find the title
        const h1Match = text.match(/<h1[^>]*>([^<]+)<\/h1>/);
        const title = h1Match ? h1Match[1].trim() : fileName; // Use the file name if <h1> is not found
        // Find all matches of tags within the 'post-tags' span
        const matches = text.matchAll(/<span class="post-tags">([\s\S]*?)<\/span>/g);

        for (const match of matches) {
            const tags = match[1].match(tagRegExp);

            if (tags) {
                // Remove square brackets and trim whitespace from tags
                const cleanedTags = tags.map(tag => tag.replace(/\[|\]/g, '').trim());
                tagsByFile[title] = cleanedTags;
            }
        }
    }
    // console.log(tagsByFile)
    return tagsByFile;
}
function fetchFileNamesFromPostsDirectory() {

    return fetch('../')
        .then(response => response.text())
        .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const links = doc.querySelectorAll('a');

            // Filter for links that point to .md files
            const mdFileNames = []
            links.forEach(link => {
              href=link.getAttribute('href');
              if (href && href.startsWith('/articles')){
                mdFileNames.push(href)
              }

            })

            return mdFileNames;
        });
}

// Define a function to create the graph
function createTagGraph(tagsByFile) {
    // Create an array of unique tags and titles
    const allTags = [...new Set(Object.values(tagsByFile).flat())];
    const allTitles = Object.keys(tagsByFile);

    const nodes = allTags.concat(allTitles).map(node => ({ id: node }));
    const links = [];

    // Create connections between title nodes and corresponding tag nodes
    allTitles.forEach(title => {
        const tags = tagsByFile[title];

        if (tags) {
            tags.forEach(tag => {
                // Check if both title and tag nodes exist in the nodes array
                const titleNode = nodes.find(node => node.id === title);
                const tagNode = nodes.find(node => node.id === tag);

                if (titleNode && tagNode) {
                    links.push({ source: titleNode, target: tagNode });
                }
            });
        }
    });

    // Create the D3 force simulation
    const width = 600//graphContainer.clientWidth;
    const height = 600//graphContainer.clientHeight;
    const svg = d3.select(graphContainer).append('svg').attr('width', "100%").attr('height', "100%");
    const simulation = d3.forceSimulation(nodes)
        .force('charge', d3.forceManyBody().strength(-30))
        .force('link', d3.forceLink(links).distance(5))
        .force('center', d3.forceCenter(width / 2, height / 2));

    // Create links
    const link = svg.selectAll('line').data(links).enter().append('line');

    // Create nodes
    const node = svg.selectAll('circle').data(nodes).enter().append('circle')
        .attr('r', d => allTags.includes(d.id) ? 8 : 5) // Adjust node size based on tag or title
        .attr('fill', d => allTags.includes(d.id) ? ' #ea5130' : ' #3095ea') // Node color based on tag or title
        .call(d3.drag()
            .on('start', dragStarted)
            .on('drag', dragging)
            .on('end', dragEnded));

    // Create labels for nodes
    // const label = svg.selectAll('text').data(nodes).enter().append('text')
    //     .text(d => d.id)
    //     .attr('class', 'node-label');

    // Update positions on tick
    simulation.on('tick', () => {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y)
            .attr('stroke',"black");

        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

        // label
        //     .attr('x', d => d.x + (allTags.includes(d.id) ? 15 : 20)) // Adjust label position based on tag or title
        //     .attr('y', d => d.y + 5);
    });

    function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragging(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
}

// Call the functions to fetch and create the graph
fetchFileNamesFromPostsDirectory()
    .then(fileNames => {
        return fetchAndParseMarkdownFiles(fileNames);
    })
    .then(tagsByFile => createTagGraph(tagsByFile))
    .catch(error => console.error('Error:', error));
</script>
{%endraw%}

<div class="tags">
  <ul class="label">
    {% for tag in site.tags %}
    <li>
      <a href="#{{ tag[0] }}">
        <span>{{ tag[0] }}</span>
        <span class="count">{{ tag[1] | size }}</span>
      </a>
    </li>
    {% endfor %}
  </ul>

  {% for tag in site.tags %}
    <h2 id="{{ tag[0] }}">
      {{ tag[0] }}
    </h2>
    <ul class="tag">
      {% for post in tag[1] %}
        {% if post.title != null %}
          <li>
            {% if post.link %}
              <a href="{{ post.link }}">
            {% else %}
              <a href="{{ site.baseurl }}{{ post.url }}">
            {% endif %}
                {{ post.title }}
              </a>
              <time>{{ post.date | date: "%Y-%m-%d" }}</time>
          </li>
        {% endif %}
      {% endfor %}
    </ul>
  {% endfor %}
</div>
